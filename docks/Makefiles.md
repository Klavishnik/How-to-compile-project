
# Make
## Для кого и для чего

Для всех. Для автоматизации сборки вашего проекта. 
Сборка - это когда из файликов вашего проекта собирается исполняемый файл.

# Этапы компиляции
## Препроцессинг
Это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования. На данной стадии  происходит работа с препроцессорными директивами. Например, препроцессор добавляет заголовочные файлы в код ` (#include) `, убирает комментирования, заменяет макросы ` (#define) ` их значениями, выбирает нужные куски кода в соответствии с условиями  ` #if, #ifdef и #ifndef `.

На этом этапе не происходит компиляция как такова. Происходит вставка все заголовочных файлов, дефайнов и уже полученный файл потом компилируется.
Используем флаг  `` -E ``

``` gcc -E main.c -o 1.txt ```

В файле 1.txt  будет настоящий код вашей программки, который будет компилироваться.
## Компиляция
На данном шаге компилятор  выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код. Это промежуточный шаг между высокоуровневым языком и машинным (бинарным) кодом.
```
  gcc -S main.c -o main.s 
```

## Ассемблирование
Так как x86 процессоры исполняют команды на бинарном коде, необходимо перевести ассемблерный код в машинный с помощью ассемблера.

Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле (файле с расширением .о)
``` 
  as main.s -o main.o
```

## Компоновка (Линкова)
Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. 

``` 
gcc main.o -o bin
```
` bin ` - исполняемый файл

Объединение этапов
Когда мы пишем 
```
gcc main.c -o bin
```

И получаем из файлика с исходным кодом исполняемый файл. 
Но мы же не пишем руками все эти флаги, верно?
Потому что, если в явном виде не указан один из флагов выше, то **выполняются все четыере этапа сборки в исполняемый файлы.**

Если у нас все в одном файле, то проблем нет. А если в проекте несколько файлов? 
Руками каждый раз компилировать и линковать файлы каждый достаточно грустно. 
Давайте автоматизирум?

# Сборка проекта

В качествет тестового примера предлагаю скачать данные из репозитория:
https://github.com/Klavishnik/How_to_fuzz_lab

Там уже есть Makefile. Мы напишем свой.
В данном проекте есть три файлика
```tree
project

│   
├── lib
│   └──string.c
│   └──string.h
│── main.c
```

Нам нужно отдельно скомпилировать файлы нашей папки ` lib ` и  `main.c `

Выполним следующие команды (будем использовать компилятор clang. Он круче)
```
clang -c main.c -o main.o
clang -c lib/string.c -o string.o
clang main.o string.o -o bin -lreadline
```
Флагом ` -c ` мы объединяем два этапа - компиляция и ассемблирования. Из файла с исходным кодом получаем объектный файлик.
Флагом ` -o ` в янвном виде указываем название файла, который у нас получится в результате выполнения команды.

На этапе линковки мы также подключаем динамические (shared) библиотеки.
Так для этой задачи мы заиствовали фнукцию из билиотки readline. 
Данная библиотека есть в системе. Чтобы использовать функцию, мы должны **прилинковать** данную библиотеку флагом `-lreadline`

# Автоматизация сборки
Для автоматизации сборки есть ряд программ, но все они инкапсулируют работу программы ` make `.
Данная утилитка принимает на вход ` Makefile ` (именно с таким названием).

Создаем данный флайик и пишем туда следующее:
```
all:
    clang -c main.c -o main.o
    clang -c lib/string.c -o string.o
    clang main.o string.o -o bin -lreadline
```
Сохраняеем файл. 

Теперь, если находясь внутри папки мы запустим make
`` make ``
То просиходит следующее:

make  начинает искать внутри директории Makefile и если находит, выполянет стадию `` all ``.

Все, простейший makefile написан. Вы автоматизировали сборку своего проекта.

# Копаем глубже
Что же такое `` all `` ?
Make работает **стадиями**, которые принимает в качестве аргумента.
Если аргумента нет, то make выполняет стадию `` all ``.
Т.е. в Makefile должна быть стадия all. 
Как описать стадию?

Добавим к файлику выше еще одну стадию.
Пишем *название*, например **clean**
Далее, нажимет Enter и tab (табаемся). 
Все что внутри стадии должно быть с отступом. 
Пишем:
```
clean:
      rm -rf *.o
      rm bin
```
Если выполнить 
```
make clean
```
То внутри папки будут удалены все файлики с расширением .o, а также исполняемый файлик bin. 

Т.е. make в качестве аргумента примет название той стадии, которую нужно выполнить.
А как выполнить несколько стадий?

Изменим Makefile вот так:
```
all: build clean
build:
    clang -c main.c -o main.o
    clang -c lib/string.c -o string.o
    clang main.o string.o -o bin -lreadline
clean:
      rm -rf *.o
      rm bin
```
Старую стадию `` all `` мы заменили на стадию `` build ``.
В стадии `` all `` появился вызов стадий `` build `` и `` clean ``
Теперь, вызвав просто `` make `` мы выполним обе стадии, т.е. скопмилируем проект и удалим все новые файлы.

Напоминаю, чтобы вызвать **конкретную** стадию, пишем:
```
make build
make clean
```
Так мы по очереди вызвали обе стадии.

## Пример Makefile
Пишем Make
```
all: build clean
build:
    clang -c main.c -o main.o
    clang -c lib/string.c -o string.o
    clang main.o string.o -o bin -lreadline
    
debug:
    clang -c main.c -o main.o -g
    clang -c lib/string.c -o string.o -g
    clang main.o string.o -o bin -lreadline
    
clean:
      rm -rf *.o
      rm bin
```
Тут мы добавили стадию `` debug `` - в ней добавлены отладочные стадии при компиляции.
Это пригодится, если придется отлаживать программу с помощью  `gdb `.

## Makefile который не Makefile
А если у нас Makefile имеет другое название? Например file_make?
Используй флаг -f
```
make -f file_make
make debug -f file_make
```

# Going depper.

Слышали про переменные? 
Раскрою секрет - в make они тоже есть.

## Стандатный переменные
### Переменная CC

`` CC `` - так мы назвали переменную. Вообще это **стандартное название** ( CC - compiler C) для переменной, которая хранит компилятор для Си.
```
CC=clang
all: build clean
build:
    $(CC) -c main.c -o main.o
    $(CC) -c lib/string.c -o string.o
    $(CC) main.o string.o -o bin -lreadline
    
debug:
    $(CC) -c main.c -o main.o -g
    $(CC) -c lib/string.c -o string.o -g
    $(CC) main.o string.o -o bin -lreadline
    
clean:
      rm -rf *.o
      rm bin
```

Тут мы заменили clang на переменную CC. Чтобы make подставил значение переменной, при её **вызове нужно использовать значок доллара $**. 

### Переменная CFLAGS

Некоторые флаги, например флаг `` -g `` или `` 02 `` - это флаги компилятора. Их нужно ставить на **этапе компиляции** .

Для флагов компилятора есть стандартная переменная CFLAGS.

Сделаем ткаой код:

```
CC=clang
CFLAGS=-g
all: build clean
build:
    $(CC) -c main.c -o main.o
    $(CC) -c lib/string.c -o string.o
    $(CC) main.o string.o -o bin -lreadline
    
debug:
    $(CC) -c main.c -o main.o $(CFLAGS)
    $(CC) -c lib/string.c -o string.o $(CFLAGS)
    $(CC) main.o string.o -o bin -lreadline
    
clean:
      rm -rf *.o
      rm bin
```

### Переменная LD и LDFLAGS
`` LD  `` - это линковщик. В нашей ситуации компилятор и линковщик - одинаковы, поэтому данной переменной переопределять его не будем.
А вот `` LDFLAGS `` - это флаги линковки. Это `` -lm `` и ``-lreadline ``


```
CC=clang
CFLAGS=-g
LDFLAGS=-lreadline
all: build clean
build:
    $(CC) -c main.c -o main.o
    $(CC) -c lib/string.c -o string.o
    $(CC) main.o string.o -o bin -$(LDFLAGS)
    
debug:
    $(CC) -c main.c -o main.o $(CFLAGS)
    $(CC) -c lib/string.c -o string.o $(CFLAGS)
    $(CC) main.o string.o -o bin -lreadline
    
clean:
      rm -rf *.o
      rm bin
```

## Собственные переменные

Переменная на то и переменная, что её можно определить любую. 
Например, я хочу добавить санитайзеры к нашему проектуи  под это дело сделаю свою переменную ``ASAN``

```
CC=clang
CFLAGS=-g
LDFLAGS=-lreadline
ASAN=-fsanitize=address

all: build clean
build:
    $(CC) -c main.c -o main.o
    $(CC) -c lib/string.c -o string.o
    $(CC) main.o string.o -o bin -$(LDFLAGS)
    
debug:
    $(CC) -c main.c -o main.o $(CFLAGS) $(ASAN)
    $(CC) -c lib/string.c -o string.o $(CFLAGS) $(ASAN)
    $(CC) main.o string.o -o bin -lreadline $(ASAN)
    
clean:
      rm -rf *.o
      rm bin
```

# Переопредление переменных из системы

Удалим из Makefile'a переменную СС
```
CC=clang   <---- Вот эту строку удалить
CFLAGS=-g  
```
и выполним `` make ``.

Ошибок не будет - код соберется. 
Почему?
Потому что СС это стандартная переменная и она определена в системе.
На сервере это **сс** (а это clang).

**Переменные можно переоределить внутри системы**

Допустим, хочу не ``clang``, а `` gcc `` в качестве компилятора

Пишу в консоли (не в Makefile)
```
export CC=gcc
```
Данной коммандой мы переоделели переменную оболочки.
Выполним `make`
И видим, что сборка пошла с gcc.


**Чтобы убрать переменную в оружении**
```
unset CC
```



## Успехов 

